function xn = nodalPolynomRoots(a, b, polynomCoeff)
% принимает аргументы: границы отрезка [a, b], коэффициенты полинома, узлы
% которого будет считать

% коэффициенты узлового полинома: w = x^3 + a(2)*x^2 + a(1)*x + a(0)

% исходная функция
w = @(x) x.^3 + polynomCoeff(3) .* (x .^ 2) + polynomCoeff(2) .* x + polynomCoeff(1);
% ее производная           
dw = @(x) 3 .* (x.^2) + polynomCoeff(3) .* 2 .* x + polynomCoeff(2);

% локализация корней
N = 5;             % число отрезков, на которые будем делить отрезок [a, b]
xn = zeros(3, 1);   % n-ые приближения, сперва начальные
k = 0;              % номер корня
while k < 3         % пока не будут найдены все три корня
    N = N * 2;         % число отрезков, на которые будем делить отрезок [a, b]
    h = (b - a) / N;    % длина шага
    x1 = a;             % левая граница первого отрезка
    for i = 1 : N       % проходим по всем кусочкам отрезка
        x2 = a + i * h; % правая граница отрезка
        if w(x1) * w(x2) < 0        % разные ли знаки у функции на границах отрезка?
            disp('Тут есть корень!!!')
            disp([x1 x2])  
            k = k + 1;          % увеличиваем количество найденных корней
            xn(k) = x1 + (x2 - x1) / 2;   % устанавливаем начальное приближение для найденных корней - середина куска, на котором он был локализован
            % считаем корень с точностью 1e-12
            while abs(w(xn(k)) ./ dw(xn(k))) > 1e-11
                xn(k) = xn(k) - w(xn(k)) ./ dw(xn(k));      % формула Ньютона
            end
            % убираем найденный корень из вариантов
            % w = @(x) (x.^3 + polynomCoeff(3) .* (x .^ 2) + polynomCoeff(2) .* x + polynomCoeff(1)) / (x - xn(k));
        end
        if k == 3
            break;      % если нашли три корня, то больше не идем по кусочкам
        end
        x1 = x2;    % переходим к следующему кусочку
    end     % прошли все кусочки
% если не нашли 3 корня, будем проходить отрезок заново с меньшим шагом
end

disp('Корни узлового полинома')
disp(vpa(xn, 13))

