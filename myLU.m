function [L, U, P, counter] = myLU(A)   %делает LUP - разложение матрицы A, считает количество произведенных арифметических операций = counter
L = eye(size(A));
U = zeros(size(A));
P = eye(size(A));
counter = 0;
% assert(forall(size(A) == size(L)))
for r = 1:size(A)-1
    i = r + 1;
    %если на диагонали 0 -- меняем строки
    if abs(A(r, r)) < 1e-14
        while abs(A(i, r)) < 1e-14
            i = i + 1;
            if i > size(A, 1) %i < количества строк -- прошли весь столбец, так и не нашли ненулевой элемент
                disp('Матрица вырожденная');
                return;
            end;
        end;
        %нашли ненулевой элемнт в столбце, Меняем строки
        APL = [A P L];  %соединяем матрицы в одну, чтобы менять строки только один раз
        temp = APL(i, :);
        APL(i, :) = APL(r, :);
        APL(r, :) = temp;
        i = i + 1;
        %возвращаем матрицы с поменявшимися строками
        A = APL(:, 1:size(A, 2));
        P = APL(:, [1:size(A, 2)] + size(A, 2));
        L = APL(:, [1:size(A, 2)] + 2 * size(A, 2));
    end
    %далее на диагонали A не 0
    for i = r + 1 : size(A)
        k = A(i, r) / A(r, r);		%коэффициент, на который домножаем строку
        counter = counter + 1;        %считаем арифметические операции
        A(i, r : size(A)) = A(i, r : size(A)) - A(r, r : size(A)) * k;  %записываем новое значение для А
        counter = counter + 2 * length(r : size(A)); 
        %записываем коэффициент в матрицу L
        L(i, r) = k;
    end; 
end; %сделали диагональную матрицу
U = A;      %матрица U -- остаток матрицы A
disp('   При LUP-разложении произведено арифметических операций')
disp(counter)
end
